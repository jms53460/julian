#Checking Rice DNA-seq

ssh jms53460@xfer.gacrc.uga.edu
mkdir /work/bnlab/Aug_27_2025_Seq
cd /work/bnlab/Aug_27_2025_Seq

sftp 24323-Julian.Mary.Somers@38.122.175.98
#Password: vQ3yCb

get -r 24323-09-09062025_153845

exit
###
mkdir /scratch/jms53460/Rice_DNA2
mkdir /scratch/jms53460/Rice_DNA2/Raw_Data
cp /work/bnlab/Aug_2025_Azenta/30-1222177457/00_fastq/NRE*gz /scratch/jms53460/Rice_DNA2/Raw_Data


mkdir /scratch/jms53460/Maize_8-10_2025
mkdir /scratch/jms53460/Maize_8-10_2025/Raw_Data

cp /work/bnlab/Aug_27_2025_Seq/24323-09-09062025_153845/M* /scratch/jms53460/Maize_8-10_2025/Raw_Data
cp /work/bnlab/September2025Sequencing/Nelms_M* /scratch/jms53460/Maize_8-10_2025/Raw_Data
cp /work/bnlab/October_2025_Sequencing/m* /scratch/jms53460/Maize_8-10_2025/Raw_Data

cd /scratch/jms53460/Maize_8-10_2025/

curl -s https://download.maizegdb.org/Zm-A188-REFERENCE-KSU-1.0/Zm-A188-REFERENCE-KSU-1.0.fa.gz > Zm_A188.fa.gz
cp /home/jms53460/Zm-B73-REFERENCE-NAM-5.0.fa .
cp /home/jms53460/Zm-B73-REFERENCE-NAM-5.0_Zm00001eb.1.gff3 .
gzip -d Zm_A188.fa.gz

cp /home/jms53460/CELSeq_barcodes.txt .

#Need to get rid of unplaced scaffolds, only leaving the chromosomes, for syri to work.

grep -n ">" Zm-B73-REFERENCE-NAM-5.0.fa
24742658:>chr10
26648102:>scaf_21
head -26648101 Zm-B73-REFERENCE-NAM-5.0.fa > Zm_B73_trim.fa


grep -n ">" Zm_A188.fa
24992964:>chr10
26915829:>c01_001
head -26915828 Zm_A188.fa > Zm_A188_trim.fa



#!/bin/bash
#SBATCH --job-name=Zm_minimap_syri                                         # Job name
#SBATCH --partition=batch                                                  # Partition (queue) name
#SBATCH --ntasks=1                                                         # Single task job
#SBATCH --cpus-per-task=6                                                  # Number of cores per task
#SBATCH --mem=350gb                                                        # Total memory for job
#SBATCH --time=24:00:00                                                    # Time limit hrs:min:sec
#SBATCH --output=/scratch/jms53460/Maize_8-10_2025/Zm_minimap_syri.out          # Location of standard output file
#SBATCH --error=/scratch/jms53460/Maize_8-10_2025/Zm_minimap_syri.err           # Location of error log file
#SBATCH --mail-user=jms53460@uga.edu                                       # Where to send mail
#SBATCH --mail-type=END,FAIL                                               # Mail events (BEGIN, END, FAIL, ALL)

cd /scratch/jms53460/Maize_8-10_2025

ml minimap2/2.28-GCCcore-13.2.0
minimap2 -t 6 -ax asm10 --eqx Zm_B73_trim.fa Zm_A188_trim.fa > A188_aligned_to_B73.sam

ml SyRI/1.7.1-foss-2023a
syri -c A188_aligned_to_B73.sam -r Zm_B73_trim.fa -q Zm_A188_trim.fa -k -F S


###Now I will convert the vcf to a tsv file and edit it to be a SNP file ready for SNPsplit

#!/bin/bash
#SBATCH --job-name=Zm_vcf2tsvpy                                           # Job name
#SBATCH --partition=batch                                                 # Partition (queue) name
#SBATCH --ntasks=1                                                        # Single task job
#SBATCH --cpus-per-task=1                                                 # Number of cores per task
#SBATCH --mem=50gb                                                        # Total memory for job
#SBATCH --time=6:00:00                                                    # Time limit hrs:min:sec
#SBATCH --output=/scratch/jms53460/Maize_8-10_2025/Zm_vcf2tsvpy.out       # Location of standard output file
#SBATCH --error=/scratch/jms53460/Maize_8-10_2025/Zm_vcf2tsvpy.err        # Location of error log file
#SBATCH --mail-user=jms53460@uga.edu                                      # Where to send mail
#SBATCH --mail-type=END,FAIL                                              # Mail events (BEGIN, END, FAIL, ALL)

cd /scratch/jms53460/Maize_8-10_2025
ml Mamba/23.11.0-0
source activate /home/jms53460/vcf2tsvpy
vcf2tsvpy --input_vcf syri.vcf --out_tsv Zm_B73_A188_vcf_table.tsv 
conda deactivate




###Selected columns from the vcf_table
awk '{print $3,$1,$2,$6,$4,$5}' Zm_B73_A188_vcf_table.tsv OFS="\t" > Zm_variants.tsv
grep -i "chr" Zm_variants.tsv > Zm_variants2.tsv
grep -i "SNP" Zm_variants2.tsv > Zm_snps.tsv

###Alter the table to match required SNP file format
ml R/4.4.2-gfbf-2024a
R
Zm_snps <- read.csv("Zm_snps.tsv", sep="")
Zm_SNPs = Zm_snps[,(1:4)]
Zm_SNPs[,5] = paste(Zm_snps[,5], "/", Zm_snps[,6], sep = "")
colnames(Zm_SNPs) = c("ID", "Chr", "Position", "SNP value", "Ref/SNP")
Zm_SNPs$"SNP value" = 1
write.table(Zm_SNPs, file = 'Zm_B73_A188_SNPs.tab', col.names = TRUE, row.names = FALSE, sep = '\t', quote = FALSE)
nrow(Zm_SNPs) #5,602,377 SNPs
q()



#!/bin/bash
#SBATCH --job-name=Zm_nmask                                               # Job name
#SBATCH --partition=batch                                                 # Partition (queue) name
#SBATCH --ntasks=1                                                        # Single task job
#SBATCH --cpus-per-task=1                                                 # Number of cores per task
#SBATCH --mem=50gb                                                        # Total memory for job
#SBATCH --time=12:00:00                                                    # Time limit hrs:min:sec
#SBATCH --output=/scratch/jms53460/Maize_8-10_2025/Zm_nmask.out                # Location of standard output file
#SBATCH --error=/scratch/jms53460/Maize_8-10_2025/Zm_nmask.err                 # Location of error log file
#SBATCH --mail-user=jms53460@uga.edu                                      # Where to send mail
#SBATCH --mail-type=END,FAIL                                              # Mail events (BEGIN, END, FAIL, ALL)

cd /scratch/jms53460/Maize_8-10_2025
ml BEDTools/2.31.1-GCC-13.3.0
bedtools maskfasta -fi Zm_B73_trim.fa -fo Zm_B73_A188_N-masked_genome.fa -bed syri.vcf -fullHeader


cp Zm_B73_A188_N-masked_genome.fa /home/jms53460
cp Zm_B73_A188_SNPs.tab /home/jms53460



#!/bin/bash
#SBATCH --job-name=Maize_SGT_pipeline                                     # Job name
#SBATCH --partition=batch                                                 # Partition (queue) name
#SBATCH --ntasks=1                                                        # Single task job
#SBATCH --cpus-per-task=6                                                 # Number of cores per task
#SBATCH --mem=400gb                                                       # Total memory for job
#SBATCH --time=48:00:00                                                   # Time limit hrs:min:sec
#SBATCH --output=/scratch/jms53460/Maize_8-10_2025/SGT_Pipeline.out       # Location of standard output file
#SBATCH --error=/scratch/jms53460/Maize_8-10_2025/SGT_Pipeline.err        # Location of error log file
#SBATCH --mail-user=jms53460@uga.edu                                      # Where to send mail
#SBATCH --mail-type=END,FAIL                                              # Mail events (BEGIN, END, FAIL, ALL)

cd /scratch/jms53460/Maize_8-10_2025

mkdir Demultiplexed
ml Mamba/23.11.0-0
source activate /home/jms53460/Fastq-Multx
module load fastp/0.23.4-GCC-13.2.0

for file in Raw_Data/*_R1_*.gz; do
    filename=$(basename "$file")
    file2=$(echo "$filename" | sed 's/_R1.*//' | sed 's/_R2_001.fastq.gz//')

    if [ ! -f "Demultiplexed/""$file2""_1s.fastq.gz" ]; then
	    #Move UMI to header
        fastp -w 6 -i "$file" -I "Raw_Data/""$file2""_R2_001.fastq.gz" -o "Demultiplexed/umi_""$file2""_R1.fastq.gz" -O "Demultiplexed/umi_""$file2""_R2.fastq.gz" -A -Q -L -G --umi --umi_loc read2 --umi_len 10 --umi_prefix UMI
        
        #Split read 2 file by CELseq barcodes. Require perfect match to barcode in expected location
	    fastq-multx -b -B "CELSeq_barcodes.txt" -m 0 "Demultiplexed/umi_""$file2""_R2.fastq.gz" "Demultiplexed/umi_""$file2""_R1.fastq.gz" "Raw_Data/""$file2""_R2_001.fastq.gz" -o "Demultiplexed/""$file2""_%_R2.fastq.gz" "Demultiplexed/""$file2""_%.fastq.gz" "Demultiplexed/""$file2""_%_umi.fastq.gz"

    fi
done
conda deactivate

mkdir SRA_upload
module load fastp/0.23.4-GCC-13.2.0

for file in Demultiplexed/*s.fastq.gz; do
	file2="${file:14:-9}"

    #Trim UMI containing read to only contain the UMI
    fastp -w 6 -B 10 -i "Demultiplexed/""$file2"".fastq.gz" -I "Demultiplexed/""$file2""_umi.fastq.gz" -o "SRA_upload/""$file2"".fastq.gz" -O "SRA_upload/""$file2""_umi.fastq.gz" -A -Q -L -G

done

mkdir hisat2_out
for file in Demultiplexed/*s.fastq.gz; do
	file2="${file:14:-9}"

if [ ! -f "hisat2_out/""$file2"".bam" ]; then

    #Trim poly A's
	fastp -w 6 -i "$file" -o "hisat2_out/""$file2"".fastq.gz" -y -x -3 -a AAAAAAAAAAAA

fi
done

ml HISAT2/2.2.1-gompi-2023a
hisat2-build Zm_B73_A188_N-masked_genome.fa Zm_B73_A188_N-masked_genome_index
ml SAMtools/1.21-GCC-13.3.0
for file in hisat2_out/*s.fastq.gz
do
	file2="${file:11:-9}"

if [ ! -f "hisat2_out/""$file2"".bam" ]; then

	hisat2 -p 6 --dta -x Zm_B73_A188_N-masked_genome_index -U "hisat2_out/""$file2"".fastq.gz" | samtools view -bS -> "hisat2_out/""$file2""_unsorted.bam"
	samtools sort -@ 6 "hisat2_out/""$file2""_unsorted.bam" -o "hisat2_out/""$file2""_s.bam"
    samtools index -@ 6 "hisat2_out/""$file2""_s.bam"
	
fi
done


mkdir SNPsplit
module load SNPsplit/0.6.0-GCC-11.3.0-Perl-5.34.1
for file in "hisat2_out/"*_s.bam
do
    file2="${file:11:-6}"

    SNPsplit --conflicting -o SNPsplit --snp_file Zm_B73_A188_SNPs.tab "$file"
    samtools sort -@ 6 SNPsplit/"$file2"_s.allele_flagged.bam -o SNPsplit/"$file2"_SNPsplit.bam
    
done


for file in "SNPsplit/"*_s.genome1.bam
do
    file2="${file:9:-14}"
    samtools sort -@ 6 "$file" -o SNPsplit/"$file2"_SNPsplit_g1.bam
done

for file in "SNPsplit/"*_s.genome2.bam
do
    file2="${file:9:-14}"
    samtools sort -@ 6 "$file" -o SNPsplit/"$file2"_SNPsplit_g2.bam
done


mkdir featurecounts
mkdir bams
mkdir UMIcounts
mkdir UMIcounts_g1
mkdir UMIcounts_g2
ml Mamba/23.11.0-0
source activate /home/jms53460/subread-env

featureCounts -T 6 -s 1 -a Zm-B73-REFERENCE-NAM-5.0_Zm00001eb.1.gff3 -t 'gene' -g 'ID' -o featurecounts/read_counts.tab --readExtension5 500 -R BAM SNPsplit/*_SNPsplit.bam
featureCounts -T 6 -s 1 -a Zm-B73-REFERENCE-NAM-5.0_Zm00001eb.1.gff3 -t 'gene' -g 'ID' -o featurecounts/read_counts_g1.tab --readExtension5 500 -R BAM SNPsplit/*_SNPsplit_g1.bam
featureCounts -T 6 -s 1 -a Zm-B73-REFERENCE-NAM-5.0_Zm00001eb.1.gff3 -t 'gene' -g 'ID' -o featurecounts/read_counts_g2.tab --readExtension5 500 -R BAM SNPsplit/*_SNPsplit_g2.bam

conda deactivate



for file in "featurecounts/"*SNPsplit.bam*
do
    file2="${file:14:-22}"
    if [ ! -f "UMIcounts/${file2}.tsv" ]; then

        ml SAMtools/1.21-GCC-13.3.0
        samtools sort -@ 6 "$file" -o "bams/$file2"
        samtools index "bams/$file2"

        module load UMI-tools/1.1.4-foss-2023a
        umi_tools count --per-gene --gene-tag=XT --assigned-status-tag=XS -I "bams/$file2" -S "UMIcounts/${file2}.tsv"
    fi
done

for file in "featurecounts/"*g1.bam*
do
    file2="${file:14:-22}"
    if [ ! -f "UMIcounts_g1/${file2}.tsv" ]; then

        ml SAMtools/1.21-GCC-13.3.0
        samtools sort -@ 6 "$file" -o "bams/$file2"
        samtools index "bams/$file2"

        module load UMI-tools/1.1.4-foss-2023a
        umi_tools count --per-gene --gene-tag=XT --assigned-status-tag=XS -I "bams/$file2" -S "UMIcounts_g1/${file2}.tsv"
    fi
done

for file in "featurecounts/"*g2.bam*
do
    file2="${file:14:-22}"
    if [ ! -f "UMIcounts_g2/${file2}.tsv" ]; then

        ml SAMtools/1.21-GCC-13.3.0
        samtools sort -@ 6 "$file" -o "bams/$file2"
        samtools index "bams/$file2"

        module load UMI-tools/1.1.4-foss-2023a
        umi_tools count --per-gene --gene-tag=XT --assigned-status-tag=XS -I "bams/$file2" -S "UMIcounts_g2/${file2}.tsv"
    fi
done




ml R/4.4.2-gfbf-2024a
R
genes = read.table('Zm-B73-REFERENCE-NAM-5.0_Zm00001eb.1.gff3', sep = '\t', quote = "")[,c(1,3,5,9)]
annots = strsplit(genes[,4], ';')
annots = unlist(lapply(annots, function(xx) { xx[1] }))
annots = sub('ID=', '', annots)
genes[,4] = annots
genes = genes[grep('gene', genes[,2]),]
rownames(genes) = genes[,4]
genes = genes[,c(1,3,4)]
colnames(genes) = c('Chr', 'Position', 'Gene')


files = dir('UMIcounts')
A = matrix(NA, nrow = length(rownames(genes)), ncol = length(files))
rownames(A) = rownames(genes)
colnames(A) = files
for (f in files) {
	xx = read.table(paste('UMIcounts/', f, sep = ''), sep = '\t', quote="", header=T, row.names=1)
	A[,f] = xx[match(rownames(genes),rownames(xx)),1]
}
colnames(A) = sub('_SNPsplit.tsv', '', sub('Nelms_', '', sub('S130_L004_', '', sub('m3', 'M3', sub('S5_', '', sub('S4_', '', sub('S18_', '', sub('S19_', '', colnames(A)))))))))
A[is.na(A)] = 0

B = A[order(rownames(A)),]
B2 = B
B = B[!duplicated(rownames(B)),]
for (g in unique(rownames(B)[duplicated(rownames(B))])) {
	B[g,] = colSums(B2[rownames(B2) %in% g,])
}
D=B

files = dir('UMIcounts_g1')
A = matrix(NA, nrow = length(rownames(genes)), ncol = length(files))
rownames(A) = rownames(genes)
colnames(A) = files
for (f in files) {
	xx = read.table(paste('UMIcounts_g1/', f, sep = ''), sep = '\t', quote="", header=T, row.names=1)
	A[,f] = xx[match(rownames(genes),rownames(xx)),1]
}
colnames(A) = sub('_SNPsplit_g1.tsv', '', sub('Nelms_', '', sub('S130_L004_', '', sub('m3', 'M3', sub('S5_', '', sub('S4_', '', sub('S18_', '', sub('S19_', '', colnames(A)))))))))
A[is.na(A)] = 0

B = A[order(rownames(A)),]
B2 = B
B = B[!duplicated(rownames(B)),]
for (g in unique(rownames(B)[duplicated(rownames(B))])) {
	B[g,] = colSums(B2[rownames(B2) %in% g,])
}
g1=B

files = dir('UMIcounts_g2')
A = matrix(NA, nrow = length(rownames(genes)), ncol = length(files))
rownames(A) = rownames(genes)
colnames(A) = files
for (f in files) {
	xx = read.table(paste('UMIcounts_g2/', f, sep = ''), sep = '\t', quote="", header=T, row.names=1)
	A[,f] = xx[match(rownames(genes),rownames(xx)),1]
}
colnames(A) = sub('_SNPsplit_g2.tsv', '', sub('Nelms_', '', sub('S130_L004_', '', sub('m3', 'M3', sub('S5_', '', sub('S4_', '', sub('S18_', '', sub('S19_', '', colnames(A)))))))))
A[is.na(A)] = 0

B = A[order(rownames(A)),]
B2 = B
B = B[!duplicated(rownames(B)),]
for (g in unique(rownames(B)[duplicated(rownames(B))])) {
	B[g,] = colSums(B2[rownames(B2) %in% g,])
}
g2=B

genes = genes[order(genes[,2]),] #order by position
genes = genes[order(genes[,1]),] #order by chr

reads = read.table('featurecounts/read_counts.tab', sep = '\t', quote = "", header=T, row.names=1)[,6:485]
colnames(reads) = sub('SNPsplit.', '', sub('_SNPsplit.bam', '', sub('Nelms_', '', sub('S130_L004_', '', sub('m3', 'M3', sub('S5_', '', sub('S4_', '', sub('S18_', '', sub('S19_', '', colnames(A))))))))))

D = D[rownames(genes),order(colnames(D))]
reads = reads[rownames(D),colnames(D)]
g1 = g1[rownames(genes), colnames(D)]
g2 = g2[rownames(genes), colnames(D)]

genes[,1] = sub('chr', '', genes[, 1])

save(D,g1,g2,genes,reads, file = "Maize_8-10_2025.RData")

q()



###Copying this to my local computer
scp sapelo2:/scratch/jms53460/Maize_8-10_2025/Maize_8-10_2025.RData 'C:/Users/julia/OneDrive/Desktop/Grad School/Nelms lab/Bioinformatics/R'

###In local R terminal
setwd('C:/Users/julia/OneDrive/Desktop/Grad School/Nelms lab/Bioinformatics/R')
load('Maize_8-10_2025.RData')

library(readxl)
Stages <- read_excel("C:/Users/julia/OneDrive/Desktop/Grad School/Nelms lab/Bioinformatics/R/Maize_Stages.xlsx")
#set.seed(1)
#Stages = Maize_Stages[sample(nrow(Stages), round(nrow(Stages)/2)),]

Meta <- Stages[rep(row.names(Stages), each = 8), ]
Meta = as.data.frame(Meta)
rownames(Meta) = paste(rep(Stages$Plate, each = 8), '_', rep((as.numeric(sub('[A-Z].+','',Stages$Celseq_primer)) - 1)*8, each = 8) + rep(1:8, nrow(Stages)), 's', sep ='')

library(tidyverse)

Meta$No_cell2 = unlist(lapply(Stages$No_cell, function(xx) {       
        out = rep('N', 8)
        out[as.numeric(strsplit(xx,',')[[1]])] = 'Y'
        return(out) }))

#vals is the values in the per bud metadata table
#the result will be per cell with buds in the same order as that table

D = D[,rownames(Meta)]
g1 = g1[,rownames(Meta)]
g2 = g2[,rownames(Meta)]


NCpairs0 = t(sapply(strsplit(Stages$No_cell, ','), function(xx) { as.numeric(xx)[1:2] }))
NCpairs = sweep(NCpairs0, 1, (1:nrow(NCpairs0) - 1)*8, '+')
NCpairs = data.frame(NC1 = rownames(Meta)[NCpairs[,1]], NC2 = rownames(Meta)[NCpairs[,2]])

NCpairs0 = cbind(NCpairs0, abs(NCpairs0[,2] - NCpairs0[,1]))
NCpairs_UMIs = data.frame(UMIs_1 = colSums(D)[NCpairs[,1]], UMIs_2 = colSums(D)[NCpairs[,2]], Mean_UMIs = (colSums(D)[NCpairs[,1]] + colSums(D)[NCpairs[,2]])/2)

summary(NCpairs_UMIs[-grep("ETOH", rownames(NCpairs_UMIs)),1]) #No cell UMIs summary for BBB samples
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    593    1047    1456    1871    1978   10861
summary(NCpairs_UMIs[grep("ETOH", rownames(NCpairs_UMIs)),1]) #No cell UMIs summary for ETOH samples
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   7400    9434   15884   18639   21324   50931

plot(colSums(D[,grep("BBB", rownames(Meta))][,which(Meta[grep("BBB", rownames(Meta)),13] == "Y")]), colSums(D[,grep("ETOH", rownames(Meta))][,which(Meta[grep("BBB", rownames(Meta)),13] == "Y")]), xlim=c(0,1400), ylim=c(0,51000), pch=19, cex=3, xlab = 'original bead purification', ylab = 'ethanol precipitation with bead purification')
abline(b=30,a=-10000, col='purple2')
abline(b=2,a=0, col='red2')




colSums(D[,grep('BBB', colnames(D))])

plot(colSums(D[,grep('BBB', colnames(D))]),colSums(D[,grep('ETOH', colnames(D))]), pch=19, cex=1, xlab = 'original bead purification', ylab = 'ethanol precipitation with bead purification')
#abline(b=1,a=0)
abline(b=2,a=0, col='red2')
abline(h=50000)
abline(v=2500)
abline(v=25000, col='green2')
abline(b=20,a=0, col='purple2')


BINZ = function (xx, bin = 10^6) 
{
    bin = as.numeric(genes[, 1]) * 10^6 + round(genes[, 2]/bin)
    out = by(xx, bin, colSums)
    out2 = t(matrix(unlist(out), nrow = ncol(g1)))
    colnames(out2) = colnames(g1)
    rownames(out2) = names(out)
    return(out2)
}


library(ggplot2)
library(ggpubr)
g1_bin = BINZ(g1)
g2_bin = BINZ(g2)
AlleleFrac_bin = g1_bin/(g1_bin + g2_bin)
AlleleFrac_bin[(g1_bin+g2_bin) < 10] = NA #remove bins with <10 genoinformative transcripts
binUse = which(abs(rowMeans(AlleleFrac_bin, na.rm=T) - .5) < .4)  # Exclude bins with >90% of all transcripts mapping to the same allele across all samples
AlleleFrac_bin[-binUse,] = NA
FracMono_all = 100*colMeans(abs(AlleleFrac_bin - .5) >= .3, na.rm=T)

#over30k = names(which(colSums(D) >52000))
#over30k = over30k[which(Rice_meta[over30k,12] == "N")] #getting rid of the 2 no cell controls
#length(which(Rice_meta[over30k,9] == "tetrads")) #9 tetrads, 7 tetrad_sep, 12 UM, 11 UM/BM, 41 BM, 15 BM/Tri, 107 Tri >25k
#length(which(Rice_meta[which(Rice_meta[,9] == "Tri"),12] == "N")) #31 tetrads, 50 tetrad_sep, 397 UM, 54 UM/BM, 132 BM, 21 BM/Tri, 177 Tri samples total

ratio = g1/(g1+g2)
ratio[(g1+g2) < 10] = NA
geneExclude = which(abs(rowMeans(ratio, na.rm=T) - .5) < .4)
ratio[-geneExclude,] = NA


plotScaleBar = ggplot() + scale_x_continuous(expand=c(0,0), limits = c(-10, max(genes[,2])/10^6 + 10), breaks = seq(0,300,20)) + theme(panel.background = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.line.x=element_line(), plot.margin = margin(0,0,0,0,'cm')) + xlab('Chromosome position (Mb)')
plotChr = function (cell, chr, pad = 10) 
{
    Cdat = data.frame(f_col0 = ratio[, cell], Chr = genes[,1], 
        Position = genes[,2]/10^6)
    Cdat = Cdat[Cdat$Chr == chr, ]
    ggplot(Cdat) + geom_rect(data = data.frame(xmin = -pad, xmax = max(genes[,2])/10^6 + 
        pad, ymin = 0, ymax = 1), aes(xmin = xmin, xmax = xmax, 
        ymin = ymin, ymax = ymax), fill = "#EEEEEE") + geom_point(aes(y = f_col0, 
        x = Position), cex = 3) + geom_hline(yintercept = 0.5, 
        linetype = "dashed") + theme(panel.background = element_blank(), 
        axis.title = element_blank(), panel.border = element_blank(), 
        panel.grid = element_blank(), axis.ticks.x = element_blank(), 
        axis.text.x = element_blank()) + scale_y_continuous(breaks = seq(0, 
        1, 0.25), labels = c("0%", "", "50%", "", "100%"), limits = c(-0.4, 
        1.05)) + scale_x_continuous(expand = c(0, 0)) + annotate("segment", 
        x = -pad, xend = -pad, y = 0, yend = 1) + theme(plot.margin = margin(0, 
        0, 0.15, 0, "cm"))
}


plotChr2 = function (cell, chr = 1, pad = 3) 
{
    Cdat = data.frame(f_col0 = AlleleFrac2[, cell], Chr = Sl_genes[,1], 
        Position = Sl_genes[,2]/10^6)
    Cdat = Cdat[Cdat$Chr == chr, ]
    ggplot(Cdat) + geom_rect(data = data.frame(xmin = -pad, xmax = max(Sl_genes[,2])/10^6 + 10, 
        ymin = 0, ymax = 1), aes(xmin = xmin, xmax = xmax, 
        ymin = ymin, ymax = ymax), fill = "#EEEEEE") + geom_point(aes(y = f_col0, 
        x = Position), cex = 3) + geom_hline(yintercept = 0.5, 
        linetype = "dashed") + theme(panel.background = element_blank(), 
        axis.title = element_blank(), panel.border = element_blank(), 
        panel.grid = element_blank(), axis.ticks.x = element_blank(), 
        axis.text.x = element_blank()) + scale_y_continuous(breaks = seq(0, 
        1, 0.25), labels = c("0%", "", "50%", "", "100%"), limits = c(-0.4, 
        1.05)) + scale_x_continuous(expand = c(0, 0)) + annotate("segment", 
        x = -pad, xend = -pad, y = 0, yend = 1) + theme(plot.margin = margin(0, 
        0, 0.15, 0, "cm"))
}


plotCell = function (cell) 
{
    annotate_figure(ggarrange(plotChr(cell, chr = 1), plotChr(cell, 
        chr = 2), plotChr(cell, chr = 3), plotChr(cell, chr = 4), 
        plotChr(cell, chr = 5), plotChr(cell, chr = 6), plotChr(cell, chr = 7),
        plotChr(cell, chr = 8), plotChr(cell, chr = 9), plotChr(cell, chr = 10),
        plotScaleBar, ncol = 1, nrow = 11, align = "v", 
        heights = c(rep(1, 10), 0.4)), left = text_grob("          % Transcripts from B73 allele", 
        rot = 90, size = 10), top = cell)
}

names(which(FracMono_all[over30k] < 90)) #Checked these, ones below look a bit intermediate?
plotCell('M37_48_ETOH_32s') #no cell
plotCell('M37_48_ETOH_51s') #no cell


plotCell('M25-36_90s')
plotCell('M37_48_ETOH_1s')
plotCell('M37_48_ETOH_4s')
plotCell('M37_48_ETOH_19s')
plotCell('M37_48_ETOH_62s')
plotCell('M37_48_ETOH_64s')
plotCell('M37_48_ETOH_70s')
plotCell('M37_48_ETOH_71s')
plotCell('M37_48_ETOH_72s')
plotCell('M37_48_ETOH_76s')
plotCell('M37_48_ETOH_82s')
plotCell('M37_48_ETOH_95s')



plot(FracMono_all[over30k[grep('BBB', over30k)]],FracMono_all[sub('BBB', 'ETOH', over30k[grep('BBB', over30k)])], pch=19, cex=3, xlab = 'original bead purification', ylab = 'ethanol precipitation with bead purification')


#length(which(Rice_meta[over30k,9] == "tetrads")) #8 tetrads, 4 tetrad_sep, 11 UM, 10 UM/BM, 40 BM, 15 BM/Tri, 103 Tri >30k



library('ComplexHeatmap')
#svg('Rice_7-8_2025_AlleleFrac_Heatmap.svg', width=6.5, height=5)
Heatmap(AlleleFrac_bin, name = 'AlleleFrac',
    top_annotation = HeatmapAnnotation(UMIcounts = log(colSums(D),10), 
    "FracMono" = FracMono_all, ">30,000 UMIs" = colSums(D) > 30000,
    col = list(">30,000 UMIs" = c("TRUE" = "red3", "FALSE" = "blue3"))),
    col = colorRampPalette(c('#0571b0','#92c5de','#f7f7f7','#f4a582','#ca0020'))(100), 
    cluster_rows=F, cluster_columns=F, show_row_names = F, show_column_names = F, use_raster=F)
#dev.off()


#Stage_order = order(factor(Rice_meta$Stage, levels = c('tetrads','tetrad_sep','UM','UM/BM','BM','BM/Tri','Tri','Tri_shed')))
#names(Stage_order) = rownames(Rice_meta[Stage_order,])
#Stage_order2 = Stage_order[which(names(Stage_order) %in% over30k)]

#FracMonoVsStage = data.frame(FracMono = FracMono_all[Stage_order2], Stage = Rice_meta$Stage[Stage_order2], Bud = Rice_meta$Sample[Stage_order2], No_cell = Rice_meta$No_cell2[Stage_order2], UMIs = colSums(D[,Stage_order2]))

#svg('Rice_7-8_2025_AlleleFrac_Heatmap.svg', width=6.5, height=5)
#Heatmap(AlleleFrac_bin[,Stage_order2], name = 'AlleleFrac',
#    top_annotation = HeatmapAnnotation(Stage = as.matrix(Rice_meta[Stage_order2,9]), UMIcounts = log(colSums(D[,Stage_order2]),10), 
#    "FracMono" = FracMono_all[Stage_order2], ">30,000 UMIs" = colSums(D[,Stage_order2]) > 30000,
#    col = list(Stage = c("tetrads" = "#ffffff","tetrad_sep" = "#ffffff", "UM" = "#eeeeee", "UM/BM" = "#cccccc", "BM" = "#777777", "BM/Tri" = "#444444", "Tri" = "#111111", "Tri_shed" = "#111111"), ">10,000 UMIs" = c("TRUE" = "red3", "FALSE" = "blue3"))),
#    col = colorRampPalette(c('#0571b0','#92c5de','#f7f7f7','#f4a582','#ca0020'))(100), 
#    cluster_rows=F, cluster_columns=F, show_row_names = F, show_column_names = F)
#dev.off()


pseudocount = 1*10^6/quantile(colSums(D), p = .1)
A2 = sweep(D, 2, colSums(D), '/')*10^6  # Transcripts per million normalization
A2b = log(A2+pseudocount,10)  # Log transform


A2d = A2b[rowSums(D[,colnames(A2b)] >= 10) >= 10, ]  # Require each gene to have at least 10 UMIs in at least 10 cells
fano = apply(A2d, 1, var)/rowMeans(A2d)  # fano factor is a measure of gene variance

over30k = names(which(colSums(D) >25000))
ETOH_Remove = names(which(colSums(D[,over30k[grep("ETOH", over30k)]]) < 51000))
over30k = over30k[-which(over30k %in% ETOH_Remove)]

#over30k = over30k[1:136]
hmat = A2d[rank(-fano[rownames(A2d)]) <= 500,over30k]
minmax = function(x) {
	sweep(x - log(pseudocount, 10), 1, apply(x - log(pseudocount, 10), 1, max), '/')
}

library(circlize)
FracMono_col = colorRamp2(c(0, 100), c("white", "purple4"))
UMI_col = colorRamp2(c(4.4, 6.0), c("white", "forestgreen"))



source('Pseudotime Velocity Functions.R')


stages = as.character(Meta[over30k,10])
names(stages) = over30k
stages = factor(stages, levels = c('UM','UM/BM','BM','BM/Tri','Tri','Tri_shed'))

pVel = function (xx, nboot = 200) 
{
    xx = t(xx)
    stages = as.numeric(stages)
    names(stages) = rownames(xx)
    #M1_samples = names(which(stages <= 5))
    #G_samples = names(which(stages >= 5))
    set.seed(1)
    out = NULL
    for (i in 1:nboot) {
        samps = sample(rownames(xx), replace = T)
        pT = pseudotime(xx[samps, ], stages)

        #pT[, 2] = pT[, 2] - mean(apply(pT, 1, diff), na.rm = T)
        #pT = rowMeans(pT, na.rm = T)
        pT = 100 * (pT - quantile(pT, 0.1))/diff(quantile(pT, c(0.1, 0.9)))
        names(pT) = samps
        out = c(out, pT)
        if (i == 1) {
            cat("0% |---------|---------|---------|---------| 100%\n   .")
        }
        if ((i%%round(nboot/40)) == 0) {
            cat(".")
        }
    }
    pT = by(out, names(out), mean)[rownames(xx)]
    pV = c(rep(NA, 4), velFn(pT[order(pT)]), rep(NA, 4))
    pV = pV/median(pV, na.rm = T)
    return(list(pT = pT, pV = pV))
}

pseudos = pVel(A2d[rank(-fano) <= 2000,over30k], nboot = 80)  # Calculate pseudotime and pseudotime velocity using accessory functions in R script
ords = order(stages, pseudos$pT)  # order samples based on morphologically-defined stage, then order samples within a stage by pseudotime

peaks = pseudoPeaks(pseudos,ords)
#stages2 = as.character(stages)
#stages2[ords][stages2[ords] == 'UM-BM'] = c('Early','Middle','Late','BM')[sapply(1:349, function(i) { sum(i >= peaks) })[stages2[ords] == 'UM-BM']]
#stages = factor(stages2, levels = c("Interphase", "Leptotene", "Zygotene", "Pachytene", "M1", "Dyad", "Tetrad", "Early", "Middle", "Late", "BM", "Pollen"))

hmat2 = A2d[,over30k][rank(-fano[rownames(A2d)]) <= 500,ords]

#Anther_length_col = colorRamp2(c(0.9, 2.0), c("white", "#A8450C"))
#library(seriation)
o1 = seriate(dist(t(scale(t(hmat2)))), method = "OLO")


#library('ComplexHeatmap')


#svg('Maize_12_1_Express_heatmap.svg', width=7, height=4)
Heatmap(minmax(hmat2), name = 'expression
level (TPM)', heatmap_legend_param = list(at = c(0, 1), labels = c(0, "max")),
    top_annotation = HeatmapAnnotation(Stage = stages[ords], #"No cell" = Meta[over30k,13][ords],
    "% Monoallelic" = FracMono_all[over30k][ords], 
    col = list(Stage = c("UM" = "#F9A729", "UM/BM" = "#F9D23C", "BM" = "#5FBB68", "BM/Tri" = "#64CDCC", "Tri" = "#A4A4D5", 
    "Tri_shed" = "#BBC9E5"), "% Monoallelic" = FracMono_col)),
    col = colorRampPalette(c('#0571b0','#92c5de','#f7f7f7','#f4a582','#ca0020'))(100), cluster_rows=as.dendrogram(o1[[1]]), cluster_columns=F, show_row_names = FALSE, show_column_names = FALSE)
#dev.off()

svg('Maize_12_1_AlleleFrac_cor.svg', width=7, height=40)
Heatmap(cor(AlleleFrac_bin[,over30k], use = 'pairwise.complete.obs', method = 'pearson'), name = 'AlleleFrac_cor', col = colorRampPalette(c('#0571b0','#92c5de','#f7f7f7','#f4a582','#ca0020'))(100))
dev.off()

svg('Maize_12_1_AlleleFrac_cor.svg', width=7, height=40)
Heatmap(cor(AlleleFrac_bin[,over30k], use = 'pairwise.complete.obs', method = 'pearson'), name = 'AlleleFrac_cor', col = colorRampPalette(c('#0571b0','#92c5de','#f7f7f7','#f4a582','#ca0020'))(100))
dev.off()


ggarrange(plotCell("M25-36_32s"), plotCell("M25-36_80s"), ncol=2)



#svg('Rice_7_2025_Expression_heatmap.svg', width=6, height=4.5)
Heatmap(minmax(hmat), name = 'expression
level (TPM)', heatmap_legend_param = list(at = c(0, 1), labels = c(0, "max")),
    top_annotation = HeatmapAnnotation(FracMono = FracMono_all[over30k], UMIcounts = log(colSums(D[,over30k]),10),
    No_cell = Meta[over30k,13], Stage = Meta[over30k,10],
    col = list(Stage = c("UM" = "#F9A729", "BM" = "#5FBB68", "BM/Tri" = "#64CDCC", "Tri" = "#A4A4D5", 
    "Tri_shed" = "#BBC9E5"), FracMono = FracMono_col, UMIcounts = UMI_col, 
    No_cell = c('Y' = 'black', 'N' = 'white'))), 
    col = colorRampPalette(c('#0571b0','#92c5de','#f7f7f7','#f4a582','#ca0020'))(100), cluster_rows=T, cluster_columns=T, show_row_names = FALSE, show_column_names = TRUE)
#dev.off()





plotScaleBar = ggplot() + scale_x_continuous(expand=c(0,0), limits = c(-10, max(B[B[,1] == 4,3])/10^6 + 10), breaks = seq(0,300,50)) + theme(panel.background = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.line.x=element_line(), plot.margin = margin(0,0,0,0,'cm')) + xlab('Chromosome position (Mb)')

plotChr = function(cell, chr = 1, minReads = 10) {
	if (class(cell) == 'character') { cell = which(colnames(UMIs) == cell) }
	a = g1[rownames(B),cell]
	b = g2[rownames(B),cell]

	Cdat = data.frame(Transcripts = a+b, f_B73 = a/(a+b), Chr = B[,1], Position = B[,3]/10^6)
	Cdat = Cdat[(rownames(B) %in% names(geneUse)) & (Cdat$Transcripts >= minReads) & (Cdat$Chr == chr),]

    Red_g = data.frame(AlleleFrac = ratio["Zm00001d053251",cell], Pos = B["Zm00001d053251",3]/10^6)

	ggplot(Cdat) + geom_rect(data=data.frame(xmin = -10, xmax = max(B[B[,1] == 4,3])/10^6 + 10, ymin = 0, ymax = 1), aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), fill='#EEEEEE') + geom_point(aes(y = f_B73, x = Position), cex = 1) + geom_hline(yintercept=0.5, linetype='dashed') + theme(panel.background = element_blank(), axis.title = element_blank(), panel.border = element_blank(), panel.grid=element_blank(), axis.ticks.x = element_blank(), axis.text.x=element_blank()) + scale_y_continuous(breaks = seq(0,1,.25), labels = c('0%', '', '50%', '', '100%'), limits = c(-.4,1.05)) + scale_x_continuous(expand=c(0,0)) + annotate('segment', x = -10, xend = -10, y = 0, yend = 1) + theme(plot.margin = margin(0,0,0.15,0,'cm')) + geom_point(data = Red_g, aes(y = AlleleFrac, x = Pos), cex = 1, col = "red2")
}

Fig1e = annotate_figure(ggarrange(plotChr('Lane1_RPI6_78s', chr = 4), plotChr('Lane1_RPI6_90s', chr = 4), plotChr('Lane1_RPI6_75s', chr = 4), plotScaleBar, ncol = 1, nrow = 4, align = 'v', heights = c(rep(1,3), .4)), left = text_grob('          % Transcripts from B73 allele', rot = 90, size = 10))

svg('3_maize_pollen_chr4_mdr1.svg', width=2, height=2.5)
Fig1e
dev.off()



######

# For General plotting
require(ggplot2)
require(ggpubr)

# For the heatmap in Fig. 1f
require(ComplexHeatmap)
require(seriation)

# To calculate pseudotime and pseudotime velocity for Fig. 1f
require(princurve)
require(RSpectra)

# Load transcript count data and metadata from GEO accession GSE175505
meta = read.csv('GSE175505_Sample_Metadata.csv.gz', row.names=1)  # This file is also identical to Table S1 of Nelms and Walbot (2021)
A = read.csv('GSE175505_Pollen_scRNAseq_transcript_counts.csv.gz', row.names=1)

# Remove samples that did not pass quality control
A = A[,sub('s_.+','s',colnames(A)) %in% (rownames(meta)[meta[,11] == 'Y'])]  
meta = meta[unique(sub('s_.+','s',colnames(A))),]

# Separate data into 3 matrices: the total number of transcripts per precursor (UMIs), the number of genoinformative transcripts matching the B73 allele (g1), and the number of genoinformative transcripts matching the A188 allele (g2)
UMIs = A[,seq(1,ncol(A),4)] + A[,seq(2,ncol(A),4)] + A[,seq(3,ncol(A),4)] + A[,seq(4,ncol(A),4)]
colnames(UMIs) = sub('_cf', '', colnames(UMIs))
g1 = A[,seq(2,ncol(A),4)]
g2 = A[,seq(3,ncol(A),4)]

B = read.csv(file = 'Gene locations.csv', row.names = 1)

stages = as.character(meta[,4])
Late_UM_table = as.data.frame(matrix(data = c(g1["Zm00001d022124",which(stages == "Late")],g2["Zm00001d022124",which(stages == "Late")]), nrow = 2, ncol = length(which(stages == "Late")), byrow=TRUE))
Late_UM_table = as.data.frame(matrix(data = c(g1["Zm00001d012675",which(stages == "Late")],g2["Zm00001d012675",which(stages == "Late")]), nrow = 2, ncol = length(which(stages == "Late")), byrow=TRUE))

BM_table = as.data.frame(matrix(data = c(g1["Zm00001d012675",which(stages == "BM")],g2["Zm00001d012675",which(stages == "BM")]), nrow = 2, ncol = length(which(stages == "BM")), byrow=TRUE))



source('Pseudotime Velocity Functions.R')

# The stages variable contains all the stages as defined by morphology alone
stages = as.character(meta[,4])
#stages[meta[,3] %in% c('UM','UM-BM','BM')] = 'UM-BM'
stages = factor(stages, levels = c("Interphase", "Leptotene", "Zygotene", "Pachytene", "M1", "Dyad", "Tetrad", "UM-BM", "Pollen"))

pseudocount = 1*10^6/quantile(colSums(UMIs), p = .1)
A2 = sweep(UMIs, 2, colSums(UMIs), '/')*10^6  # Transcripts per million normalization
A2b = log(A2+pseudocount,10)  # Log transform
A2d = A2b[rowSums(UMIs[,colnames(A2b)] >= 10) >= 10, ]  # For pseudotime analysis, require each gene to have at least 10 UMIs in at least 10 cells
fano = apply(A2d, 1, var)/rowMeans(A2d)  # fano factor is a measure of gene variance

pseudos = pVel(A2d[rank(-fano) <= 2000,], nboot = 80)  # Calculate pseudotime and pseudotime velocity using accessory functions in R script
ords = order(stages, pseudos$pT)  # order samples based on morphologically-defined stage, then order samples within a stage by pseudotime

peaks = pseudoPeaks(pseudos,ords)
stages2 = as.character(stages)
stages2[ords][stages2[ords] == 'UM-BM'] = c('Early','Middle','Late','BM')[sapply(1:349, function(i) { sum(i >= peaks) })[stages2[ords] == 'UM-BM']]
stages = factor(stages2, levels = c("Interphase", "Leptotene", "Zygotene", "Pachytene", "M1", "Dyad", "Tetrad", "Early", "Middle", "Late", "BM", "Pollen"))

minmax = function(x) {
	sweep(x - log(pseudocount, 10), 1, apply(x - log(pseudocount, 10), 1, max), '/')
}

BINZ = function (xx, bin = 10^6) 
{
    bin = as.numeric(B[, 1]) * 10^6 + round(B[, 3]/bin)
    out = by(xx, bin, colSums)
    out2 = t(matrix(unlist(out), nrow = ncol(g1)))
    colnames(out2) = colnames(g1)
    rownames(out2) = names(out)
    return(out2)
}


library(ggplot2)
library(ggpubr)
g1_bin = BINZ(g1[rownames(B),])
g2_bin = BINZ(g2[rownames(B),])
AlleleFrac_bin = g1_bin/(g1_bin + g2_bin)
AlleleFrac_bin[(g1_bin+g2_bin) < 10] = NA #remove bins with <10 genoinformative transcripts
Z_binUse = which(abs(rowMeans(AlleleFrac_bin, na.rm=T) - .5) < .4)  # Exclude bins with >90% of all transcripts mapping to the same allele across all samples
AlleleFrac_bin[-Z_binUse,] = NA
FracMono_all = 100*colMeans(abs(AlleleFrac_bin - .5) >= .3, na.rm=T)
names(FracMono_all) = sub("_g1", "", names(FracMono_all))


hmat2 = A2d[rank(-fano[rownames(A2d)]) <= 500,ords][,127:349]
o1 = seriate(dist(t(scale(t(hmat2)))), method = "OLO")

stages = sub("Early", "Early UM", sub("Middle", "Middle UM", sub("Late", "Late UM", stages)))
stages[grep("Floret", meta[,5])] = "UM/BM"
FracMono_col = colorRamp2(c(0, 100), c("white", "purple4"))


svg('Zm_tetrad-pollen_expression_2022_data.svg', width=6, height=4)
Heatmap(as.matrix(minmax(hmat2)), name = 'expression
level (TPM)', heatmap_legend_param = list(at = c(0, 1), labels = c(0, "max")),
    top_annotation = HeatmapAnnotation(Stage = as.matrix(stages[ords][127:349]), 
    FracMono = as.matrix(FracMono_all[ords][127:349]),
    col = list(Stage = c("Tetrad" = "#EB1E2C", "Early UM" = "#FF6F00", "Middle UM" = "#F9A729", "Late UM" = "#FFC107", 
    "UM/BM" = "#F9D23C", "BM" = "#5FBB68", "Pollen" = "#A4A4D5"), FracMono = FracMono_col),
    annotation_legend_param = list(Stage = list(at = c("Tetrad", "Early UM", "Middle UM", "Late UM", "UM/BM", "BM", "Pollen")))),
    col = colorRampPalette(c('#0571b0','#92c5de','#f7f7f7','#f4a582','#ca0020'))(100), cluster_rows=as.dendrogram(o1[[1]]), cluster_columns=F, show_row_names = FALSE, show_column_names = FALSE)
dev.off()


