#Checking Rice DNA-seq

ssh jms53460@xfer.gacrc.uga.edu
mkdir /work/bnlab/Aug_27_2025_Seq
cd /work/bnlab/Aug_27_2025_Seq

sftp 24323-Julian.Mary.Somers@38.122.175.98
#Password: vQ3yCb

get -r 24323-09-09062025_153845

exit
###
mkdir /scratch/jms53460/Rice_DNA2
mkdir /scratch/jms53460/Rice_DNA2/Raw_Data
cp /work/bnlab/Aug_2025_Azenta/30-1222177457/00_fastq/NRE*gz /scratch/jms53460/Rice_DNA2/Raw_Data


mkdir /scratch/jms53460/Maize_8-10_2025
mkdir /scratch/jms53460/Maize_8-10_2025/Raw_Data

cp /work/bnlab/Aug_27_2025_Seq/24323-09-09062025_153845/M* /scratch/jms53460/Maize_8-10_2025/Raw_Data
cp /work/bnlab/September2025Sequencing/Nelms_M* /scratch/jms53460/Maize_8-10_2025/Raw_Data
cp /work/bnlab/October_2025_Sequencing/m* /scratch/jms53460/Maize_8-10_2025/Raw_Data

cd /scratch/jms53460/Maize_8-10_2025/

curl -s https://download.maizegdb.org/Zm-A188-REFERENCE-KSU-1.0/Zm-A188-REFERENCE-KSU-1.0.fa.gz > Zm_A188.fa.gz
cp /home/jms53460/Zm-B73-REFERENCE-NAM-5.0.fa .
cp /home/jms53460/Zm-B73-REFERENCE-NAM-5.0_Zm00001eb.1.gff3 .
gzip -d Zm_A188.fa.gz

cp /home/jms53460/CELSeq_barcodes.txt .

#Need to get rid of unplaced scaffolds, only leaving the chromosomes, for syri to work.

grep -n ">" Zm-B73-REFERENCE-NAM-5.0.fa
24742658:>chr10
26648102:>scaf_21
head -26648101 Zm-B73-REFERENCE-NAM-5.0.fa > Zm_B73_trim.fa


grep -n ">" Zm_A188.fa
24992964:>chr10
26915829:>c01_001
head -26915828 Zm_A188.fa > Zm_A188_trim.fa



#!/bin/bash
#SBATCH --job-name=Zm_minimap_syri                                         # Job name
#SBATCH --partition=batch                                                  # Partition (queue) name
#SBATCH --ntasks=1                                                         # Single task job
#SBATCH --cpus-per-task=6                                                  # Number of cores per task
#SBATCH --mem=350gb                                                        # Total memory for job
#SBATCH --time=24:00:00                                                    # Time limit hrs:min:sec
#SBATCH --output=/scratch/jms53460/Maize_8-10_2025/Zm_minimap_syri.out          # Location of standard output file
#SBATCH --error=/scratch/jms53460/Maize_8-10_2025/Zm_minimap_syri.err           # Location of error log file
#SBATCH --mail-user=jms53460@uga.edu                                       # Where to send mail
#SBATCH --mail-type=END,FAIL                                               # Mail events (BEGIN, END, FAIL, ALL)

cd /scratch/jms53460/Maize_8-10_2025

ml minimap2/2.28-GCCcore-13.2.0
minimap2 -t 6 -ax asm10 --eqx Zm_B73_trim.fa Zm_A188_trim.fa > A188_aligned_to_B73.sam

ml SyRI/1.7.1-foss-2023a
syri -c A188_aligned_to_B73.sam -r Zm_B73_trim.fa -q Zm_A188_trim.fa -k -F S


###Now I will convert the vcf to a tsv file and edit it to be a SNP file ready for SNPsplit

#!/bin/bash
#SBATCH --job-name=Zm_vcf2tsvpy                                           # Job name
#SBATCH --partition=batch                                                 # Partition (queue) name
#SBATCH --ntasks=1                                                        # Single task job
#SBATCH --cpus-per-task=1                                                 # Number of cores per task
#SBATCH --mem=50gb                                                        # Total memory for job
#SBATCH --time=6:00:00                                                    # Time limit hrs:min:sec
#SBATCH --output=/scratch/jms53460/Maize_8-10_2025/Zm_vcf2tsvpy.out       # Location of standard output file
#SBATCH --error=/scratch/jms53460/Maize_8-10_2025/Zm_vcf2tsvpy.err        # Location of error log file
#SBATCH --mail-user=jms53460@uga.edu                                      # Where to send mail
#SBATCH --mail-type=END,FAIL                                              # Mail events (BEGIN, END, FAIL, ALL)

cd /scratch/jms53460/Maize_8-10_2025
ml Mamba/23.11.0-0
source activate /home/jms53460/vcf2tsvpy
vcf2tsvpy --input_vcf syri.vcf --out_tsv Zm_B73_A188_vcf_table.tsv 
conda deactivate




###Selected columns from the vcf_table
awk '{print $3,$1,$2,$6,$4,$5}' Zm_B73_A188_vcf_table.tsv OFS="\t" > Zm_variants.tsv
grep -i "chr" Zm_variants.tsv > Zm_variants2.tsv
grep -i "SNP" Zm_variants2.tsv > Zm_snps.tsv

###Alter the table to match required SNP file format
ml R/4.4.2-gfbf-2024a
R
Zm_snps <- read.csv("Zm_snps.tsv", sep="")
Zm_SNPs = Zm_snps[,(1:4)]
Zm_SNPs[,5] = paste(Zm_snps[,5], "/", Zm_snps[,6], sep = "")
colnames(Zm_SNPs) = c("ID", "Chr", "Position", "SNP value", "Ref/SNP")
Zm_SNPs$"SNP value" = 1
write.table(Zm_SNPs, file = 'Zm_B73_A188_SNPs.tab', col.names = TRUE, row.names = FALSE, sep = '\t', quote = FALSE)
nrow(Zm_SNPs) #5,602,377 SNPs
q()



#!/bin/bash
#SBATCH --job-name=Zm_nmask                                               # Job name
#SBATCH --partition=batch                                                 # Partition (queue) name
#SBATCH --ntasks=1                                                        # Single task job
#SBATCH --cpus-per-task=1                                                 # Number of cores per task
#SBATCH --mem=50gb                                                        # Total memory for job
#SBATCH --time=12:00:00                                                    # Time limit hrs:min:sec
#SBATCH --output=/scratch/jms53460/Maize_8-10_2025/Zm_nmask.out                # Location of standard output file
#SBATCH --error=/scratch/jms53460/Maize_8-10_2025/Zm_nmask.err                 # Location of error log file
#SBATCH --mail-user=jms53460@uga.edu                                      # Where to send mail
#SBATCH --mail-type=END,FAIL                                              # Mail events (BEGIN, END, FAIL, ALL)

cd /scratch/jms53460/Maize_8-10_2025
ml BEDTools/2.31.1-GCC-13.3.0
bedtools maskfasta -fi Zm_B73_trim.fa -fo Zm_B73_A188_N-masked_genome.fa -bed syri.vcf -fullHeader


cp Zm_B73_A188_N-masked_genome.fa /home/jms53460
cp Zm_B73_A188_SNPs.tab /home/jms53460



#!/bin/bash
#SBATCH --job-name=Maize_SGT_pipeline                                     # Job name
#SBATCH --partition=batch                                                 # Partition (queue) name
#SBATCH --ntasks=1                                                        # Single task job
#SBATCH --cpus-per-task=6                                                 # Number of cores per task
#SBATCH --mem=400gb                                                       # Total memory for job
#SBATCH --time=48:00:00                                                   # Time limit hrs:min:sec
#SBATCH --output=/scratch/jms53460/Maize_8-10_2025/SGT_Pipeline.out       # Location of standard output file
#SBATCH --error=/scratch/jms53460/Maize_8-10_2025/SGT_Pipeline.err        # Location of error log file
#SBATCH --mail-user=jms53460@uga.edu                                      # Where to send mail
#SBATCH --mail-type=END,FAIL                                              # Mail events (BEGIN, END, FAIL, ALL)

cd /scratch/jms53460/Maize_8-10_2025

mkdir Demultiplexed
ml Mamba/23.11.0-0
source activate /home/jms53460/Fastq-Multx
module load fastp/0.23.4-GCC-13.2.0

for file in Raw_Data/*_R1_*.gz; do
    filename=$(basename "$file")
    file2=$(echo "$filename" | sed 's/_R1.*//' | sed 's/_R2_001.fastq.gz//')

    if [ ! -f "Demultiplexed/""$file2""_1s.fastq.gz" ]; then
	    #Move UMI to header
        fastp -w 6 -i "$file" -I "Raw_Data/""$file2""_R2_001.fastq.gz" -o "Demultiplexed/umi_""$file2""_R1.fastq.gz" -O "Demultiplexed/umi_""$file2""_R2.fastq.gz" -A -Q -L -G --umi --umi_loc read2 --umi_len 10 --umi_prefix UMI
        
        #Split read 2 file by CELseq barcodes. Require perfect match to barcode in expected location
	    fastq-multx -b -B "CELSeq_barcodes.txt" -m 0 "Demultiplexed/umi_""$file2""_R2.fastq.gz" "Demultiplexed/umi_""$file2""_R1.fastq.gz" "Raw_Data/""$file2""_R2_001.fastq.gz" -o "Demultiplexed/""$file2""_%_R2.fastq.gz" "Demultiplexed/""$file2""_%.fastq.gz" "Demultiplexed/""$file2""_%_umi.fastq.gz"

    fi
done
conda deactivate

mkdir SRA_upload
module load fastp/0.23.4-GCC-13.2.0

for file in Demultiplexed/*s.fastq.gz; do
	file2="${file:14:-9}"

    #Trim UMI containing read to only contain the UMI
    fastp -w 6 -B 10 -i "Demultiplexed/""$file2"".fastq.gz" -I "Demultiplexed/""$file2""_umi.fastq.gz" -o "SRA_upload/""$file2"".fastq.gz" -O "SRA_upload/""$file2""_umi.fastq.gz" -A -Q -L -G

done

mkdir hisat2_out
for file in Demultiplexed/*s.fastq.gz; do
	file2="${file:14:-9}"

if [ ! -f "hisat2_out/""$file2"".bam" ]; then

    #Trim poly A's
	fastp -w 6 -i "$file" -o "hisat2_out/""$file2"".fastq.gz" -y -x -3 -a AAAAAAAAAAAA

fi
done

ml HISAT2/2.2.1-gompi-2023a
hisat2-build Zm_B73_A188_N-masked_genome.fa Zm_B73_A188_N-masked_genome_index
ml SAMtools/1.21-GCC-13.3.0
for file in hisat2_out/*s.fastq.gz
do
	file2="${file:11:-9}"

if [ ! -f "hisat2_out/""$file2"".bam" ]; then

	hisat2 -p 6 --dta -x Zm_B73_A188_N-masked_genome_index -U "hisat2_out/""$file2"".fastq.gz" | samtools view -bS -> "hisat2_out/""$file2""_unsorted.bam"
	samtools sort -@ 6 "hisat2_out/""$file2""_unsorted.bam" -o "hisat2_out/""$file2""_s.bam"
    samtools index -@ 6 "hisat2_out/""$file2""_s.bam"
	
fi
done


mkdir SNPsplit
module load SNPsplit/0.6.0-GCC-11.3.0-Perl-5.34.1
for file in "hisat2_out/"*_s.bam
do
    file2="${file:11:-6}"

    SNPsplit --conflicting -o SNPsplit --snp_file Zm_B73_A188_SNPs.tab "$file"
    samtools sort -@ 6 SNPsplit/"$file2"_s.allele_flagged.bam -o SNPsplit/"$file2"_SNPsplit.bam
    
done


for file in "SNPsplit/"*_s.genome1.bam
do
    file2="${file:9:-14}"
    samtools sort -@ 6 "$file" -o SNPsplit/"$file2"_SNPsplit_g1.bam
done

for file in "SNPsplit/"*_s.genome2.bam
do
    file2="${file:9:-14}"
    samtools sort -@ 6 "$file" -o SNPsplit/"$file2"_SNPsplit_g2.bam
done


mkdir featurecounts
mkdir bams
mkdir UMIcounts
mkdir UMIcounts_g1
mkdir UMIcounts_g2
ml Mamba/23.11.0-0
source activate /home/jms53460/subread-env

featureCounts -T 6 -s 1 -a Zm-B73-REFERENCE-NAM-5.0_Zm00001eb.1.gff3 -t 'gene' -g 'ID' -o featurecounts/read_counts.tab --readExtension5 500 -R BAM SNPsplit/*_SNPsplit.bam
featureCounts -T 6 -s 1 -a Zm-B73-REFERENCE-NAM-5.0_Zm00001eb.1.gff3 -t 'gene' -g 'ID' -o featurecounts/read_counts_g1.tab --readExtension5 500 -R BAM SNPsplit/*_SNPsplit_g1.bam
featureCounts -T 6 -s 1 -a Zm-B73-REFERENCE-NAM-5.0_Zm00001eb.1.gff3 -t 'gene' -g 'ID' -o featurecounts/read_counts_g2.tab --readExtension5 500 -R BAM SNPsplit/*_SNPsplit_g2.bam

conda deactivate



for file in "featurecounts/"*SNPsplit.bam*
do
    file2="${file:14:-22}"
    if [ ! -f "UMIcounts/${file2}.tsv" ]; then

        ml SAMtools/1.21-GCC-13.3.0
        samtools sort -@ 6 "$file" -o "bams/$file2"
        samtools index "bams/$file2"

        module load UMI-tools/1.1.4-foss-2023a
        umi_tools count --per-gene --gene-tag=XT --assigned-status-tag=XS -I "bams/$file2" -S "UMIcounts/${file2}.tsv"
    fi
done

for file in "featurecounts/"*g1.bam*
do
    file2="${file:14:-22}"
    if [ ! -f "UMIcounts_g1/${file2}.tsv" ]; then

        ml SAMtools/1.21-GCC-13.3.0
        samtools sort -@ 6 "$file" -o "bams/$file2"
        samtools index "bams/$file2"

        module load UMI-tools/1.1.4-foss-2023a
        umi_tools count --per-gene --gene-tag=XT --assigned-status-tag=XS -I "bams/$file2" -S "UMIcounts_g1/${file2}.tsv"
    fi
done

for file in "featurecounts/"*g2.bam*
do
    file2="${file:14:-22}"
    if [ ! -f "UMIcounts_g2/${file2}.tsv" ]; then

        ml SAMtools/1.21-GCC-13.3.0
        samtools sort -@ 6 "$file" -o "bams/$file2"
        samtools index "bams/$file2"

        module load UMI-tools/1.1.4-foss-2023a
        umi_tools count --per-gene --gene-tag=XT --assigned-status-tag=XS -I "bams/$file2" -S "UMIcounts_g2/${file2}.tsv"
    fi
done









plotScaleBar = ggplot() + scale_x_continuous(expand=c(0,0), limits = c(-10, max(B[B[,1] == 4,3])/10^6 + 10), breaks = seq(0,300,50)) + theme(panel.background = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.line.x=element_line(), plot.margin = margin(0,0,0,0,'cm')) + xlab('Chromosome position (Mb)')

plotChr = function(cell, chr = 1, minReads = 10) {
	if (class(cell) == 'character') { cell = which(colnames(UMIs) == cell) }
	a = g1[rownames(B),cell]
	b = g2[rownames(B),cell]

	Cdat = data.frame(Transcripts = a+b, f_B73 = a/(a+b), Chr = B[,1], Position = B[,3]/10^6)
	Cdat = Cdat[(rownames(B) %in% names(geneUse)) & (Cdat$Transcripts >= minReads) & (Cdat$Chr == chr),]

    Red_g = data.frame(AlleleFrac = ratio["Zm00001d053251",cell], Pos = B["Zm00001d053251",3]/10^6)

	ggplot(Cdat) + geom_rect(data=data.frame(xmin = -10, xmax = max(B[B[,1] == 4,3])/10^6 + 10, ymin = 0, ymax = 1), aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), fill='#EEEEEE') + geom_point(aes(y = f_B73, x = Position), cex = 1) + geom_hline(yintercept=0.5, linetype='dashed') + theme(panel.background = element_blank(), axis.title = element_blank(), panel.border = element_blank(), panel.grid=element_blank(), axis.ticks.x = element_blank(), axis.text.x=element_blank()) + scale_y_continuous(breaks = seq(0,1,.25), labels = c('0%', '', '50%', '', '100%'), limits = c(-.4,1.05)) + scale_x_continuous(expand=c(0,0)) + annotate('segment', x = -10, xend = -10, y = 0, yend = 1) + theme(plot.margin = margin(0,0,0.15,0,'cm')) + geom_point(data = Red_g, aes(y = AlleleFrac, x = Pos), cex = 1, col = "red2")
}

Fig1e = annotate_figure(ggarrange(plotChr('Lane1_RPI6_78s', chr = 4), plotChr('Lane1_RPI6_90s', chr = 4), plotChr('Lane1_RPI6_75s', chr = 4), plotScaleBar, ncol = 1, nrow = 4, align = 'v', heights = c(rep(1,3), .4)), left = text_grob('          % Transcripts from B73 allele', rot = 90, size = 10))

svg('3_maize_pollen_chr4_mdr1.svg', width=2, height=2.5)
Fig1e
dev.off()



######

# For General plotting
require(ggplot2)
require(ggpubr)

# For the heatmap in Fig. 1f
require(ComplexHeatmap)
require(seriation)

# To calculate pseudotime and pseudotime velocity for Fig. 1f
require(princurve)
require(RSpectra)

# Load transcript count data and metadata from GEO accession GSE175505
meta = read.csv('GSE175505_Sample_Metadata.csv.gz', row.names=1)  # This file is also identical to Table S1 of Nelms and Walbot (2021)
A = read.csv('GSE175505_Pollen_scRNAseq_transcript_counts.csv.gz', row.names=1)

# Remove samples that did not pass quality control
A = A[,sub('s_.+','s',colnames(A)) %in% (rownames(meta)[meta[,11] == 'Y'])]  
meta = meta[unique(sub('s_.+','s',colnames(A))),]

# Separate data into 3 matrices: the total number of transcripts per precursor (UMIs), the number of genoinformative transcripts matching the B73 allele (g1), and the number of genoinformative transcripts matching the A188 allele (g2)
UMIs = A[,seq(1,ncol(A),4)] + A[,seq(2,ncol(A),4)] + A[,seq(3,ncol(A),4)] + A[,seq(4,ncol(A),4)]
colnames(UMIs) = sub('_cf', '', colnames(UMIs))
g1 = A[,seq(2,ncol(A),4)]
g2 = A[,seq(3,ncol(A),4)]

B = read.csv(file = 'Gene locations.csv', row.names = 1)


source('Pseudotime Velocity Functions.R')

# The stages variable contains all the stages as defined by morphology alone
stages = as.character(meta[,4])
stages[meta[,3] %in% c('UM','UM-BM','BM')] = 'UM-BM'
stages = factor(stages, levels = c("Interphase", "Leptotene", "Zygotene", "Pachytene", "M1", "Dyad", "Tetrad", "UM-BM", "Pollen"))

pseudocount = 1*10^6/quantile(colSums(UMIs), p = .1)
A2 = sweep(UMIs, 2, colSums(UMIs), '/')*10^6  # Transcripts per million normalization
A2b = log(A2+pseudocount,10)  # Log transform
A2d = A2b[rowSums(UMIs[,colnames(A2b)] >= 10) >= 10, ]  # For pseudotime analysis, require each gene to have at least 10 UMIs in at least 10 cells
fano = apply(A2d, 1, var)/rowMeans(A2d)  # fano factor is a measure of gene variance

pseudos = pVel(A2d[rank(-fano) <= 2000,], nboot = 80)  # Calculate pseudotime and pseudotime velocity using accessory functions in R script
ords = order(stages, pseudos$pT)  # order samples based on morphologically-defined stage, then order samples within a stage by pseudotime

peaks = pseudoPeaks(pseudos,ords)
stages2 = as.character(stages)
stages2[ords][stages2[ords] == 'UM-BM'] = c('Early','Middle','Late','BM')[sapply(1:349, function(i) { sum(i >= peaks) })[stages2[ords] == 'UM-BM']]
stages = factor(stages2, levels = c("Interphase", "Leptotene", "Zygotene", "Pachytene", "M1", "Dyad", "Tetrad", "Early", "Middle", "Late", "BM", "Pollen"))

minmax = function(x) {
	sweep(x - log(pseudocount, 10), 1, apply(x - log(pseudocount, 10), 1, max), '/')
}

BINZ = function (xx, bin = 10^6) 
{
    bin = as.numeric(B[, 1]) * 10^6 + round(B[, 3]/bin)
    out = by(xx, bin, colSums)
    out2 = t(matrix(unlist(out), nrow = ncol(g1)))
    colnames(out2) = colnames(g1)
    rownames(out2) = names(out)
    return(out2)
}


library(ggplot2)
library(ggpubr)
g1_bin = BINZ(g1[rownames(B),])
g2_bin = BINZ(g2[rownames(B),])
AlleleFrac_bin = g1_bin/(g1_bin + g2_bin)
AlleleFrac_bin[(g1_bin+g2_bin) < 10] = NA #remove bins with <10 genoinformative transcripts
Z_binUse = which(abs(rowMeans(AlleleFrac_bin, na.rm=T) - .5) < .4)  # Exclude bins with >90% of all transcripts mapping to the same allele across all samples
AlleleFrac_bin[-Z_binUse,] = NA
FracMono_all = 100*colMeans(abs(AlleleFrac_bin - .5) >= .3, na.rm=T)
names(FracMono_all) = sub("_g1", "", names(FracMono_all))


hmat2 = A2d[rank(-fano[rownames(A2d)]) <= 500,ords][,127:349]
o1 = seriate(dist(t(scale(t(hmat2)))), method = "OLO")

stages = sub("Early", "Early UM", sub("Middle", "Middle UM", sub("Late", "Late UM", stages)))
stages[grep("Floret", meta[,5])] = "UM/BM"
FracMono_col = colorRamp2(c(0, 100), c("white", "purple4"))


svg('Zm_tetrad-pollen_expression_2022_data.svg', width=6, height=4)
Heatmap(as.matrix(minmax(hmat2)), name = 'expression
level (TPM)', heatmap_legend_param = list(at = c(0, 1), labels = c(0, "max")),
    top_annotation = HeatmapAnnotation(Stage = as.matrix(stages[ords][127:349]), 
    FracMono = as.matrix(FracMono_all[ords][127:349]),
    col = list(Stage = c("Tetrad" = "#EB1E2C", "Early UM" = "#FF6F00", "Middle UM" = "#F9A729", "Late UM" = "#FFC107", 
    "UM/BM" = "#F9D23C", "BM" = "#5FBB68", "Pollen" = "#A4A4D5"), FracMono = FracMono_col),
    annotation_legend_param = list(Stage = list(at = c("Tetrad", "Early UM", "Middle UM", "Late UM", "UM/BM", "BM", "Pollen")))),
    col = colorRampPalette(c('#0571b0','#92c5de','#f7f7f7','#f4a582','#ca0020'))(100), cluster_rows=as.dendrogram(o1[[1]]), cluster_columns=F, show_row_names = FALSE, show_column_names = FALSE)
dev.off()


